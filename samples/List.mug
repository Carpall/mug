type List[type G] {
	raw: [G],
	len: u32,
	seg: u32
}
func make_list[type G](segmentation: u32): List[G] {
	return List[G] {
		[G, segmentation] {},
		0,
		segmentation
	};
}
func err_outofrange(len: u32, index: u32) {
	panic("Index out of range: len "++", index "+index.to_str());
}
func err_emptylist() {
	panic("Read from an empty list");
}

func add(self: List[type G], value: G): ? {
	if self.len < self.seg {
		self.raw[self.len] = value;
		self.len++;
	} else {
		var old: [G] = self.raw;
		self.seg *= 2;
		self.raw = [G, self.seg] {};
		for i: u32 to self.len {
			self.raw[i] = old[i];
		}
		self.raw[self.len] = value;
		self.len++;
	}
}
func find(self: List[type G], value: G): bit {
	for i: u32 to self.len {
		if self.raw[i] == value {
			return true;
		}
	}
	return false;
}
func get(self: List[type G], index: u32): G {
	if index < self.len {
		return self.raw[index];
	}
	err_outofrange(self.len.to_str(), index.to_str());
}
func set(self: List[type G], index: u32, value: G): ? {
	if index < self.len {
		self.raw[index] = value;
	}
	err_outofrange(self.len.to_str(), index.to_str());
}
func pop_top(self: List[type G]): ? {
	if self.len == 0 {
		err_emptylist();
	}
	self.len--;
}
func pop(self: List[type G]): G {
	if self.len == 0 {
		err_emptylist();
	}
	return self.raw[self.len--];
}
func to_str(self: List[type G]): str {
	var res: str = "[";
	for i: u32 to self.len {
		res += ", "+self.raw[i].to_str();
	}
	return res+"]";
}