// self is a keyword

type List[type G] {
	pub read len: u32,
	raw: [G],
	seg: u32
}

func List[type G](segmentation: u32 = 100): List[G] {
	if segmentation == 0 {
		err_segmentation();
	}
	return List[G] {
		[G, segmentation] {},
		0,
		segmentation
	};
}
func UnList(self: List[type G]): null {
	mem::dealloc(self);
	return null;
}
func err_segmentation(): ? {
	panic("Segmentation must be greater than `0`");
}
func err_outofrange(len: u32, index: u32): ? {
	panic("Index out of range: len "+i32::to_str(len)+", index "+i32::to_str(index));
}
func err_emptylist(): ? {
	panic("Read from an empty list");
}

func add(self: List[type G], value: G): ? {
	if self.len < self.seg {
		self.raw[self.len] = value;
		self.len++;
	} else {
		var old: [G] = self.raw;
		self.seg *= 2;
		self.raw = [G, self.seg] {};
		for i: u32 to self.len {
			self.raw[i] = old[i];
		}
		self.raw[self.len] = value;
		self.len++;
	}
}
func find(self: List[type G], value: G): bit {
	for i: u32 to self.len {
		if self.raw[i] == value {
			return true;
		}
	}
	return false;
}
func get(self: List[type G], index: u32): G {
	if index < self.len {
		return self.raw[index];
	}
	err_outofrange(self.len.to_str(), index.to_str());
}
func set(self: List[type G], index: u32, value: G): ? {
	if index < self.len {
		self.raw[index] = value;
	}
	err_outofrange(self.len.to_str(), index.to_str());
}
func pop_top(self: List[type G]): ? {
	if self.len == 0 {
		err_emptylist();
	}
	self.len--;
}
func pop(self: List[type G]): G {
	if self.len == 0 {
		err_emptylist();
	}
	return self.raw[self.len--];
}
func to_str(self: List[type G]): str {
	var res: str = "[";
	for i: u32 to self.len {
		res += ", "+self.raw[i].to_str();
	}
	return res+"]";
}

func test(): ? {
	var list: List[i32] = List[i32](10);
	list.add(10);
	list.add(1);
	io::println(list.to_str());
	list = list.UnList();
}