type List[type G] {
	_: %[G],
	len: u32,
	seg: u32
}
func make_list[type G](segmentation: i32): List[G] {
	return {
		%[G, segmentation] {},
		0,
		segmentation
	};
}
func add(self: List[type G], value: G): ? {
	if self.len < self.seg {
		self._[self.len++] = value;
	} else {
		var old: %[G] = self._;
		self._ = %[G, self.seg*=2] {};
		for i: i32 to self.len {
			self._[i] = old[i];
		}
		self._[self.len] = value;
		self.len++;
	}
}

func find(self: List[type G], value: G): bit {
	for i: i32 to self.len {
		if self._[i] == value {
			return true;
		}
	}
	return false;
}
func get(self: List[type G], index: u32): G {
	if index <= self.len {
		return self._[index];
	}
	return null;
}
func set(self: List[type G], index: u32, value: G): ? {
	if index <= self.len {
		self._[index] = value;
	}
}
func pop_top(self: List[type G]): ? {
	if self.len > 0 {
		self._[self.len--] = null;
	}
}
func pop(self: List[type G]): G {
	if self.len == 0 {
		return null;
	}
	var tmp: G = self._[self.len-1];
	
	self._[self.len--] = null;
	return tmp;
}