/*type Node[type G] {
	value: G,
	next: ptr Node[G]
}
type LinkedList[type G] {
	link: Node[G],
	len: u32,
	max: read u32
}
func make_linkedlist[type G](max: u32): LinkedList[G] {
	return LinkedList[G] {
		Node[G] {},
		0,
		max
	};
}
func err_outofrange(len: u32, index: u32) {
	panic("Index out of range: len "++", index "+index.to_str());
}
func err_emptylist() {
	panic("Read from an empty list");
}

func add(self: LinkedList[type G], value: G): ? {
	var last: ptr Node[G] = ptr self.link;
	for i: u32 to self.len {
		last = last.next;
	}
	last.value = value;
	last.next = Node[G] {};
	self.len++;
}
func pop_top(self: LinkedList[type G]): ? {
	if self.len == 0 {
		err_emptylist();
	}
	var last: ptr Node[G] = ptr self.link;
	for i: u32 to self.len-1 {
		last = last.next;
	}
	last.value = value;
	last.next = Node[G] {};
	self.len--;
}
func pop(self: LinkedList[type G]): G {
	if self.len == 0 {
		return null;
	}
	var res: G;
	if self.len == 1 {
		res = self.link.value;
		self.link = null;
	}
	else {
		var top: ptr Node[G] = &self.link;
		for i: i32 to self.len-2 {
			top = top.next;
		}
		res = top.next.value;
		top.next = null;
	}
	self.len--;
	return res;
}
func get(self: LinkedList[type G], index: i32): G {
	if self.len == 0 || index >= self.len {
		return null;
	}
	if index == 0 {
		return self.link.value;
	}
	else {
		var top: ptr Node[G] = &self.link;
		for i: i32 to index {
			top = top.next;
		}
		return top.value;
	}
}
func tostr(self: LinkedList[type G], value: G): str {
}*/