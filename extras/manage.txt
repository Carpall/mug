CompilationMap {
   new CompilationUnit(path) & CompUnit.GenerateIR() {
      IRGenerator.GenerateIR(string) |result| {
         Parser.GenerateAST(UserInput) |ast| {
            Lexer.GenerateTC(UserInput) |tc| {
               // tokenizing UserInput into tc
            } => // parsing tc into ast
         } => // converting ast into llvm ir, doing typechecking and more
      } => WriteFile(result.TempOutputPath, result.Assembly);
      while !ExistsFile(result.TempOutputPath)
         Print('.');
      CommandPrompt("clang -S "+result.TempOutputPath+" -o "+ChangeExtension(path, "exe"))
   }
}

OnlyPublic = true
CompilationUnit(string) {
   Instances {
      IRGenerator
   }
   Methods {
      GetTokenCollection(): List[Token],
      GetParseTree(): ModuleDefinition,
      GenerateIR(): IntermediateLanguage
   }
}
TokenKinds: enum {
   ...
}
MugType: enum {
   ...
}
Token: struct {
   Kind: TokenKinds,
   Value: Object,
   Position: Range
}
Lexer: class {
   Instances {
      TokenCollection: List[Token]
   }
   Methods {
      GenerateTC(string): List[Token],
      GetInput(): string,
      GetLineInput(Token): string
   }
}
ImperativeStatement: struct {
   Kind: StatementKinds,
   Body: Object,
   Position: Range
}
ModuleDefinition: struct {
   Name: string,
   Body: List[ImperativeStatement]
}
FuncDefinition: struct {
   ReturnType: MugType,
   Name: string,
   ParameterTypes: ConstTuple,
   Body: List[ImperativeStatement]
}
Parser: class {
   Instances {
      Scanner: Lexer,
      ParseTree: List[ImperativeStatement]
   }
   Methods {
      GenerateAST(string): ModuleDefinition
   }
}
IRGlobalEmitter: class {
   Instances {
      AssemblyBuilder: StringBuilder
   }
   Methods {
      GetAssembled(): string,
      DefineFunction(FuncDefinition): void,
      DeclareFunction(MugType, string, ConstTuple): void,
      ...
   }
}
IRLobalEmitter: class {
   Instances {
      AssemblyBuilder: StringBuilder
   }
   Methods {
      GetAssembled(): string,
      CallFunction(MugType, string, ConstTuple, ConstTuple): void
      ...
   }
}
IRGenerator: class {
   Instances {
      Parser: Parser
      Emitter: IRGlobalEmitter,
      Symbols: Dictionary[string, Object]
   }
   Methods {
      GenerateIR(string): IntermediateLanguage
   }
}
IntermediateLanguage: struct {
   Assembly: string,
   CompilationTime: DateTime,
   TempOutputPath: string
}