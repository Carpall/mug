CompilationMap {
   new CompilationUnit(path) & CompUnit.GenerateIR() {
      IRGenerator.GenerateIR(string) |result| {
         Parser.GenerateAST(string) |ast| {
            Lexer.GenerateTC(string) |tc| {
               for each char in input {
                  if char == ... & next == ...
                     tok = ...
                     Add(tc, tok);
               }
            }
            while tc.next() |cur| != TokenKinds::eof {
               if isfuncdefining() {
                  if cur.kind == TokenKinds::func {
                     FailIfNextNot(TokenKinds::id);
                     ...
                  } else if cur.kind == TokenKinds::id {
                     if tc.next == TokenKinds::openpar {
                        args = FailIfNextNot(StatementKinds::consttuple);
                        params = [];
                        for each arg in args {
                           params.add(new ExpressionEvaluator().Evaluate(arg)) {
                              for each tok in input {
                                 if tok.kind == TokenKinds::plus {
                                     res.add(build, sum);
                                     build.reset();
				 }
		              }
			   }
		        }
                        AddFuncCalling(, cur.value);
                     }
	          }
               } => statement = ... ; Add(ast, statement);
            }
         }
         while ast.next() |cur| != StatementKinds::funccalling {
            CheckTypes(...);
            Emitter.emitfunctioncalling(cur.body);
            ...
         }
      } => WriteFile(result.TempOutputPath, result.Assembly);
      while !ExistsFile(result.TempOutputPath)
         Print('.');
      CommandPrompt("clang -S "+result.TempOutputPath+" -o "+ChangeExtension(path, "exe"))
   }
}

OnlyPublic = true
CompilationUnit(string) {
   Instances {
      IRGenerator
   }
   Methods {
      GetTokenCollection(): List[Token],
      GetParseTree(): ModuleDefinition,
      GenerateIR(): IntermediateLanguage
   }
}
TokenKinds: enum {
   ...
}
MugType: enum {
   ...
}
Token: struct {
   Kind: TokenKinds,
   Value: Object,
   Position: Range
}
Lexer: class {
   Instances {
      TokenCollection: List[Token]
   }
   Methods {
      GenerateTC(string): List[Token],
      GetInput(): string,
      GetLineInput(Token): string
   }
}
ImperativeStatement: struct {
   Kind: StatementKinds,
   Body: Object,
   Position: Range
}
ModuleDefinition: struct {
   Name: string,
   Body: List[ImperativeStatement]
}
FuncDefinition: struct {
   ReturnType: MugType,
   Name: string,
   ParameterTypes: ConstTuple,
   Body: List[ImperativeStatement]
}
ExpressionEvaluator: class {
   Methods {
      Evaluate(List[Token]): List[ImperativeStatement]
   }
}
Parser: class {
   Instances {
      Scanner: Lexer,
      ParseTree: List[ImperativeStatement]
   }
   Methods {
      GenerateAST(string): ModuleDefinition
   }
}
IREmitter: class {
   Instances {
      AssemblyBuilder: StringBuilder
   }
   Methods {
      GetAssembled(): string,
      EmitCall(MugType, string, ConstTuple, ConstTuple): void,
      EmitStore(MugType, string, ConstTuple, ConstTuple): void,
      EmitLoad(MugType, string, ConstTuple, ConstTuple): void
      ...
   }
}
IRGenerator: class {
   Instances {
      Parser: Parser,
      Emitter: IREmitter,
      Symbols: Dictionary[string, Object]
   }
   Methods {
      GenerateIR(string): IntermediateLanguage
   }
}
IntermediateLanguage: struct {
   Assembly: string,
   CompilationTime: DateTime,
   TempOutputPath: string
}